<!doctype html>
<meta charset="utf-8">
<title>Meme Overlay</title>
<style>
  html,body{margin:0;background:transparent;overflow:hidden}
  #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  img{max-width:100vw;max-height:100vh;opacity:0;transition:opacity .25s}
  .show{opacity:1}
</style>
<div id="wrap"><img id="img" alt="meme"></div>
<script>
(async () => {
  const qs   = new URLSearchParams(location.search);
  const cat  = (qs.get('cat') || 'memes').toLowerCase();       // anime | hmm | memes
  const mode = (qs.get('mode')|| 'reddit').toLowerCase();      // "reddit" or "list"
  const subsQ= (qs.get('subs')|| '').trim();                   // optional override: "subA,subB"

  // Only these categories/subs (SFW-ish)
  const ALLOW = {
    anime: ['animemes','animememes','goodanimemes'],
    hmm:   ['blursedimages','hmm','hmmm','HolUp'],
    memes: ['dankmemes','memes','Bossfight']
  };

  // Accept only direct image hosts
  const allowDomains = ['i.redd.it','preview.redd.it','i.imgur.com'];

  const pick = a => a[Math.floor(Math.random()*a.length)];
  const isImg = u => /\.(jpg|jpeg|png|gif|webp)(\?|$)/i.test(u);
  const host = u => { try { return new URL(u).host.toLowerCase(); } catch { return ''; } };
  const okDomain = u => allowDomains.some(d => host(u).endsWith(d));
  const unesc = s => s.replace(/&amp;/g,'&');

  async function fetchText(url){
    const r = await fetch(url, {cache:'no-store', headers:{'Accept':'text/plain, application/json'}});
    if(!r.ok) throw new Error('http '+r.status);
    return r.text();
  }

  // Optional curated list mode (memes/<cat>/index.txt)
  async function fromList(){
    const listURL = `memes/${encodeURIComponent(cat)}/index.txt`;
    const t = await fetchText(listURL);
    const urls = t.split(/\r?\n/).map(s=>s.trim())
      .filter(s=>s && !s.startsWith('#') && isImg(s) && okDomain(s));
    if (!urls.length) throw new Error('empty list');
    return pick(urls);
  }

  // Reddit mode: SFW only, skip videos/galleries, image URL or preview fallback, allowed hosts only
  async function fromReddit(){
    const subs = subsQ ? subsQ.split(',').map(s=>s.trim()).filter(Boolean)
                       : (ALLOW[cat] || []);
    if (!subs.length) throw new Error('no subs for '+cat);

    const tried = new Set();
    for (let attempt=0; attempt<Math.min(3, subs.length); attempt++){
      let sub = pick(subs);
      while (tried.has(sub) && tried.size < subs.length) sub = pick(subs);
      tried.add(sub);

      const api = `https://www.reddit.com/r/${encodeURIComponent(sub)}/hot.json?limit=50`;
      const r = await fetch(api, {headers:{'Accept':'application/json'}});
      if (!r.ok) continue;
      const j = await r.json();
      const posts = (j.data?.children||[]).map(x=>x.data).filter(Boolean);

      const images = [];
      for (const p of posts){
        if (p.over_18) continue;
        if (p.is_video) continue;
        if (p.is_gallery) continue;

        let u = (p.url_overridden_by_dest || p.url || '').trim();
        if (!isImg(u) || !okDomain(u)){
          const prev = p.preview?.images?.[0]?.source?.url;
          if (prev) u = unesc(prev);
        }
        if (u && isImg(u) && okDomain(u)) images.push(u);
      }
      if (images.length) return pick(images);
    }
    throw new Error('no reddit images');
  }

  let url = null;
  try { url = (mode==='list') ? await fromList() : await fromReddit(); }
  catch(e){ if (mode!=='list') { try { url = await fromList(); } catch{} } }
  if (!url) return;

  const img = document.getElementById('img');
  img.onload  = () => img.classList.add('show');
  img.onerror = () => console.warn('image failed', url);
  img.src = url + (url.includes('?')?'&':'?') + 't=' + Date.now(); // cache-bust
})();
</script>
