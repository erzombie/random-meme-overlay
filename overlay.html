<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Meme Overlay</title>
<style>
  html,body{margin:0;background:transparent;overflow:hidden}
  #wrap{position:fixed;inset:0}
  img{
    position:absolute; inset:0; width:100vw; height:100vh;
    object-fit:contain; object-position:center center;
    image-orientation:from-image; opacity:0; transition:opacity .25s;
  }
  .show{opacity:1}
  #msg{position:fixed; inset:0; display:none; align-items:center; justify-content:center;
       color:#ddd; text-shadow:0 1px 2px #0008; font:18px system-ui,Segoe UI,Roboto,Arial,sans-serif}
</style>
<div id="wrap"><img id="img" alt="meme"></div>
<div id="msg"></div>
<script>
(async () => {
  const qs     = new URLSearchParams(location.search);
  const rawCat = (qs.get('cat') || 'meme').toLowerCase();
  const mode   = (qs.get('mode')|| 'reddit').toLowerCase();
  const subsQ  = (qs.get('subs')|| '').trim();
  const fit    = (qs.get('fit') || 'contain').toLowerCase();
  const DEBUG  = qs.has('debug');

  const CAT_ALIAS = { memes:'meme', meme:'meme', thailand:'thai' };
  const cat = CAT_ALIAS[rawCat] || rawCat;

  const ALLOW = {
    anime: ['animemes','animememes','goodanimemes'],
    hmm:   ['blursedimages','hmm','hmmm','HolUp'],
    meme:  ['dankmemes','memes','Bossfight'],
    thai:  ['thaithai','PimThaiMaiDai']
  };

  const allowDomains = [
    'i.redd.it','preview.redd.it','external-preview.redd.it','i.imgur.com','redditmedia.com'
  ];

  const pick = a => a[Math.floor(Math.random()*a.length)];
  const isImg = u => /\.(jpg|jpeg|png|gif|webp)(\?|$)/i.test(u);
  const host  = u => { try { return new URL(u).host.toLowerCase(); } catch { return ''; } };
  const okDomain = u => allowDomains.some(d => host(u).endsWith(d));
  const clean = u => {
    if (!u) return '';
    u = u.replace(/&amp;/g,'&').trim();
    if (u.startsWith('//')) u = 'https:' + u;
    return u;
  };
  const showMsg = t => { if (!DEBUG) return; const m=document.getElementById('msg'); m.textContent=t; m.style.display='flex'; };

  async function fetchText(url){
    const r = await fetch(url, {cache:'no-store', headers:{'Accept':'text/plain, application/json'}});
    if(!r.ok) throw new Error('http '+r.status);
    return r.text();
  }

  async function fromListPool(){
    const listURL = `memes/${encodeURIComponent(cat)}/index.txt`;
    const t = await fetchText(listURL);
    const urls = t.split(/\r?\n/).map(s=>clean(s))
      .filter(s=>s && !s.startsWith('#') && isImg(s) && okDomain(s));
    return [...new Set(urls)];
  }

  async function fromRedditPool(){
    const subs = subsQ ? subsQ.split(',').map(s=>s.trim()).filter(Boolean) : (ALLOW[cat] || []);
    if (!subs.length) throw new Error('no subs for '+cat);

    const endpoints = [
      (s,which) => `https://api.reddit.com/r/${encodeURIComponent(s)}/${which}?limit=75&raw_json=1`,
      (s,which) => `https://www.reddit.com/r/${encodeURIComponent(s)}/${which}.json?limit=75&raw_json=1`
    ];
    const listings = ['hot','new','top?t=day'];

    const pool = [];

    const pushImg = (u) => {
      u = clean(u);
      if (isImg(u) && okDomain(u)) pool.push(u);
    };

    const collectFromPost = (p) => {
      if (!p) return;
      if (p.is_gallery || p.gallery_data || p.media_metadata){
        const items = (p.gallery_data?.items || []);
        if (items.length){
          for (const it of items){
            const id = it.media_id;
            const mm = p.media_metadata?.[id];
            pushImg(mm?.s?.u || mm?.s?.gif);
          }
        } else {
          const keys = Object.keys(p.media_metadata || {});
          if (keys.length){
            const mm = p.media_metadata[keys[0]];
            pushImg(mm?.s?.u || mm?.s?.gif);
          }
        }
      }
      let u = (p.url_overridden_by_dest || p.url || '').trim();
      if (isImg(u) && okDomain(u)) pushImg(u);
      const prev = p.preview?.images?.[0]?.source?.url;
      if (prev) pushImg(prev);
    };

    for (const sub of subs){
      for (const which of listings){
        for (const ep of endpoints){
          try{
            const url = ep(sub, which);
            const r = await fetch(url, {headers:{'Accept':'application/json'}});
            if (!r.ok) continue;
            const j = await r.json();
            const posts = (j.data?.children || []).map(x=>x.data).filter(Boolean);
            for (const p of posts){
              if (p.over_18) continue;
              if (Array.isArray(p.crosspost_parent_list) && p.crosspost_parent_list.length){
                collectFromPost(p.crosspost_parent_list[0]);
              } else {
                collectFromPost(p);
              }
            }
            if (pool.length) break;
          } catch {}
        }
        if (pool.length) break;
      }
    }
    return [...new Set(pool)];
  }

  // pick image with retries if one fails
  function tryDisplay(pool){
    const img = document.getElementById('img');
    img.style.objectFit = (fit === 'cover' ? 'cover' : 'contain');

    const next = () => {
      if (!pool.length){ showMsg('No image found or all failed.'); return; }
      const url = pool.splice(Math.floor(Math.random()*pool.length),1)[0];
      if (DEBUG) showMsg('Loading: ' + url);
      img.classList.remove('show');
      img.onload  = () => { img.classList.add('show'); };
      img.onerror = () => { if (DEBUG) showMsg('Failed, trying anotherâ€¦'); next(); };
      img.src = url + (url.includes('?')?'&':'?') + 't=' + Date.now();
    };
    next();
  }

  try {
    const pool = (mode==='list') ? await fromListPool() : await fromRedditPool();
    if (pool.length) { tryDisplay(pool); return; }
    if (mode!=='list') {
      const listPool = await fromListPool();
      if (listPool.length) { tryDisplay(listPool); return; }
    }
    showMsg('No image found.');
  } catch(e){
    if (mode!=='list') {
      try {
        const listPool = await fromListPool();
        if (listPool.length) { tryDisplay(listPool); return; }
      } catch {}
    }
    showMsg('No image found.');
  }
})();
</script>
