<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Meme Overlay</title>
<style>
  html,body{margin:0;background:transparent;overflow:hidden}
  #wrap{position:fixed;inset:0}
  img{
    position:absolute; inset:0;
    width:100vw; height:100vh;
    object-fit:contain;                 /* can switch via ?fit=cover */
    object-position:center center;
    image-orientation:from-image;       /* respect EXIF rotation */
    opacity:0; transition:opacity .25s;
  }
  .show{opacity:1}
  #msg{
    position:fixed; inset:0; display:none;
    align-items:center; justify-content:center;
    color:#ddd; text-shadow:0 1px 2px #0008;
    font:18px system-ui, Segoe UI, Roboto, Arial, sans-serif;
  }
</style>
<div id="wrap"><img id="img" alt="meme"></div>
<div id="msg"></div>
<script>
(async () => {
  const qs     = new URLSearchParams(location.search);
  const rawCat = (qs.get('cat') || 'meme').toLowerCase();   // default category
  const mode   = (qs.get('mode')|| 'reddit').toLowerCase(); // "reddit" | "list"
  const subsQ  = (qs.get('subs')|| '').trim();              // optional: "subA,subB"
  const fit    = (qs.get('fit') || 'contain').toLowerCase();// "contain" | "cover"
  const DEBUG  = qs.has('debug');

  // accept both "meme" and "memes", and allow future aliases
  const CAT_ALIAS = { memes:'meme', meme:'meme', thailand:'thai' };
  const cat = CAT_ALIAS[rawCat] || rawCat;

  // ---- EDIT YOUR SAFE SUBS HERE ----
  const ALLOW = {
    anime: ['animemes','animememes','goodanimemes'],
    hmm:   ['blursedimages','hmm','hmmm','HolUp'],
    meme:  ['dankmemes','memes','Bossfight'],
    thai:  ['thaithai','PimThaiMaiDai']
  };

  // allow only direct/static image hosts
  const allowDomains = [
    'i.redd.it','preview.redd.it','external-preview.redd.it','i.imgur.com','redditmedia.com'
  ];

  const pick = a => a[Math.floor(Math.random()*a.length)];
  const isImg = u => /\.(jpg|jpeg|png|gif|webp)(\?|$)/i.test(u);
  const host  = u => { try { return new URL(u).host.toLowerCase(); } catch { return ''; } };
  const okDomain = u => allowDomains.some(d => host(u).endsWith(d));
  const showMsg = t => { if (!DEBUG) return; const m=document.getElementById('msg'); m.textContent=t; m.style.display='flex'; };

  async function fetchText(url){
    const r = await fetch(url, {cache:'no-store', headers:{'Accept':'text/plain, application/json'}});
    if(!r.ok) throw new Error('http '+r.status);
    return r.text();
  }

  // ------- LIST MODE (curated text file) -------
  async function fromList(){
    const listURL = `memes/${encodeURIComponent(cat)}/index.txt`;
    const t = await fetchText(listURL);
    const urls = t.split(/\r?\n/).map(s=>s.trim())
      .filter(s=>s && !s.startsWith('#') && isImg(s) && okDomain(s));
    if (!urls.length) throw new Error('empty list');
    return pick(urls);
  }

  // ------- REDDIT MODE (handles preview, galleries, crossposts) -------
  async function fromReddit(){
    const subs = subsQ
      ? subsQ.split(',').map(s=>s.trim()).filter(Boolean)
      : (ALLOW[cat] || []);
    if (!subs.length) throw new Error('no subs for '+cat);

    const endpoints = [
      (s,which) => `https://api.reddit.com/r/${encodeURIComponent(s)}/${which}?limit=75&raw_json=1`,
      (s,which) => `https://www.reddit.com/r/${encodeURIComponent(s)}/${which}.json?limit=75&raw_json=1`
    ];
    const listings = ['hot','new','top?t=day'];

    const all = [];
    const pushImg = (u) => {
      if (!u) return;
      u = u.replace(/&amp;/g,'&').trim();
      if (isImg(u) && okDomain(u)) all.push(u);
    };

    const collectFromPost = (p) => {
      if (!p) return;
      // 1) gallery (media_metadata)
      if (p.is_gallery || p.gallery_data || p.media_metadata){
        const items = (p.gallery_data?.items || []);
        if (items.length){
          for (const it of items){
            const id = it.media_id;
            const mm = p.media_metadata?.[id];
            const u  = mm?.s?.u || mm?.s?.gif;
            if (u){ pushImg(u); if (all.length) return; }
          }
        } else {
          const keys = Object.keys(p.media_metadata || {});
          if (keys.length){
            const mm = p.media_metadata[keys[0]];
            pushImg(mm?.s?.u || mm?.s?.gif);
            if (all.length) return;
          }
        }
      }
      // 2) direct
      let u = (p.url_overridden_by_dest || p.url || '').trim();
      if (isImg(u) && okDomain(u)) { pushImg(u); if (all.length) return; }
      // 3) preview fallback
      const prev = p.preview?.images?.[0]?.source?.url;
      if (prev) { pushImg(prev); if (all.length) return; }
    };

    for (const sub of subs){
      let got = false;
      for (const which of listings){
        for (const ep of endpoints){
          try{
            const url = ep(sub, which);
            const r = await fetch(url, {headers:{'Accept':'application/json'}});
            if (!r.ok) continue;
            const j = await r.json();
            const posts = (j.data?.children || []).map(x=>x.data).filter(Boolean);
            for (const p of posts){
              if (p.over_18) continue; // SFW only
              if (Array.isArray(p.crosspost_parent_list) && p.crosspost_parent_list.length){
                collectFromPost(p.crosspost_parent_list[0]);
              } else {
                collectFromPost(p);
              }
              if (all.length) { got = true; break; }
            }
            if (got) break;
          } catch {}
        }
        if (got) break;
      }
    }

    if (!all.length) throw new Error('no reddit images');
    return pick(all);
  }

  // ------- Choose source, fallback, render -------
  let url = null;
  try {
    url = (mode==='list') ? await fromList() : await fromReddit();
  } catch(e) {
    if (DEBUG) showMsg('No image via '+mode+'. Trying list fallbackâ€¦');
    if (mode!=='list') { try { url = await fromList(); } catch {} }
  }

  if (!url) { showMsg('No image found. (Try another category or use list mode)'); return; }

  const img = document.getElementById('img');
  img.style.objectFit = (fit === 'cover' ? 'cover' : 'contain');
 
::contentReference[oaicite:0]{index=0}
