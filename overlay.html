<!doctype html>
<meta charset="utf-8">
<title>Meme Overlay</title>
<style>
  html,body{margin:0;background:transparent;overflow:hidden}
  #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  img{max-width:100vw;max-height:100vh;opacity:0;transition:opacity .25s}
  .show{opacity:1}
  #msg{position:fixed;inset:0;display:none;align-items:center;justify-content:center;
       color:#ddd;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;font-size:18px}
</style>
<div id="wrap"><img id="img" alt="meme"></div>
<div id="msg"></div>
<script>
(async () => {
  const qs   = new URLSearchParams(location.search);
  const rawCat = (qs.get('cat') || 'meme').toLowerCase();   // default to "meme"
  const mode   = (qs.get('mode')|| 'reddit').toLowerCase(); // reddit | list
  const subsQ  = (qs.get('subs')|| '').trim();              // optional override
  const DEBUG  = qs.has('debug');

  // alias so "meme" and "memes" both work; add more if needed
  const CAT_ALIAS = { memes:'meme', meme:'meme' };
  const cat = CAT_ALIAS[rawCat] || rawCat;

  const ALLOW = {
    anime: ['animemes','animememes','goodanimemes'],
    hmm:   ['blursedimages','hmm','hmmm','HolUp'],
    meme:  ['dankmemes','memes','Bossfight'],
    thai:  ['thaithai','PimThaiMaiDai']
  };

  const allowDomains = [
    'i.redd.it','preview.redd.it','external-preview.redd.it','i.imgur.com','redditmedia.com'
  ];

  const pick = a => a[Math.floor(Math.random()*a.length)];
  const isImg = u => /\.(jpg|jpeg|png|gif|webp)(\?|$)/i.test(u);
  const host  = u => { try { return new URL(u).host.toLowerCase(); } catch { return ''; } };
  const okDomain = u => allowDomains.some(d => host(u).endsWith(d));
  const showMsg = t => { if (!DEBUG) return; const m=document.getElementById('msg'); m.textContent=t; m.style.display='flex'; };

  async function fetchText(url){
    const r = await fetch(url, {cache:'no-store', headers:{'Accept':'text/plain, application/json'}});
    if(!r.ok) throw new Error('http '+r.status);
    return r.text();
  }

  // Optional curated list mode: memes/<cat>/index.txt (one URL per line)
  async function fromList(){
    const listURL = `memes/${encodeURIComponent(cat)}/index.txt`;
    const t = await fetchText(listURL);
    const urls = t.split(/\r?\n/).map(s=>s.trim())
      .filter(s=>s && !s.startsWith('#') && isImg(s) && okDomain(s));
    if (!urls.length) throw new Error('empty list');
    return pick(urls);
  }

  // Reddit mode with gallery/crosspost/preview handling
  async function fromReddit(){
    const subs = subsQ
      ? subsQ.split(',').map(s=>s.trim()).filter(Boolean)
      : (ALLOW[cat] || []);
    if (!subs.length) throw new Error('no subs for '+cat);

    const endpoints = [
      (s,which) => `https://api.reddit.com/r/${encodeURIComponent(s)}/${which}?limit=75&raw_json=1`,
      (s,which) => `https://www.reddit.com/r/${encodeURIComponent(s)}/${which}.json?limit=75&raw_json=1`
    ];
    const listings = ['hot','new','top?t=day'];

    const all = [];
    const pushImg = (u) => {
      if (!u) return;
      u = u.replace(/&amp;/g,'&').trim();
      if (isImg(u) && okDomain(u)) all.push(u);
    };

    const collectFromPost = (p) => {
      if (!p) return;
      // gallery
      if (p.is_gallery || p.gallery_data || p.media_metadata){
        const items = (p.gallery_data?.items || []);
        if (items.length){
          for (const it of items){
            const id = it.media_id;
            const mm = p.media_metadata?.[id];
            const u  = mm?.s?.u || mm?.s?.gif;
            if (u){ pushImg(u); if (all.length) return; }
          }
        } else {
          const keys = Object.keys(p.media_metadata || {});
          if (keys.length){
            const mm = p.media_metadata[keys[0]];
            pushImg(mm?.s?.u || mm?.s?.gif);
            if (all.length) return;
          }
        }
      }
      // direct
      let u = (p.url_overridden_by_dest || p.url || '').trim();
      if (isImg(u) && okDomain(u)) { pushImg(u); if (all.length) return; }
      // preview
      const prev = p.preview?.images?.[0]?.source?.url;
      if (prev) { pushImg(prev); if (all.length) return; }
    };

    for (const sub of subs){
      let got = false;
      for (const which of listings){
        for (const ep of endpoints){
          try{
            const url = ep(sub, which);
            const r = await fetch(url, {headers:{'Accept':'application/json'}});
            if (!r.ok) continue;
            const j = await r.json();
            const posts = (j.data?.children || []).map(x=>x.data).filter(Boolean);
            for (const p of posts){
              if (p.over_18) continue;
              if (Array.isArray(p.crosspost_parent_list) && p.crosspost_parent_list.length){
                collectFromPost(p.crosspost_parent_list[0]);
              } else {
                collectFromPost(p);
              }
              if (all.length) { got = true; break; }
            }
            if (got) break;
          } catch {}
        }
        if (got) break;
      }
    }

    if (!all.length) throw new Error('no reddit images');
    return pick(all);
  }

  // -------- choose source, fallback, and render one image --------
  let url = null;
  try {
    url = (mode==='list') ? await fromList() : await fromReddit();
  } catch(e) {
    if (DEBUG) showMsg('No image via '+mode+'. Trying list fallbackâ€¦');
    if (mode!=='list') { try { url = await fromList(); } catch {} }
  }

  if (!url) { showMsg('No image found. (Try another category or use list mode)'); return; }

  const img = document.getElementById('img');
  img.onload  = () => img.classList.add('show');
  img.onerror = () => showMsg('Image failed to load.');
  img.src = url + (url.includes('?')?'&':'?') + 't=' + Date.now(); // cache-bust
})();
</script>
